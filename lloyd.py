# -*- coding: utf-8 -*-
"""Lloyd.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16o-ynqu35r1lCftjOa80itUFA4Yu5ImP
"""

import sys
import numpy as np
from numpy.random import seed
import math
import matplotlib.pyplot as plt
seed(12)

def eud(ss, dd):
  b = (ss-dd) * (ss - dd)
  su = 0
  for i in range(len(b)):
    su += b[i]
  return np.sqrt(su)

def qerror(k, X, y):
  res = 0
  for i in range(1, k+1):
    a = []
    for index in range(len(y)):
      if(y[index] == i):
        a.append(X[index])
    a_su = sum(a)
    a_mean = a_su/max(len(a), 1)
    dist = []
    for j in a:
      dist.append((j-a_mean)**2)
    for d in dist:
      res += sum(d)
  return res

class IrisLloyd:
  def __init__(self, X, k, r):
    self.X = X
    self.k = k
    self.r = r
    self.n_rows, self.n_cols = X.shape
    self.k_clusters = None
    self.k_centers = None

  def _init_k_random_centers(self):
    k_random_indices = np.random.choice(self.n_rows, self.k, replace=False)
    self.k_centers = []
    for random_index in k_random_indices:
      self.k_centers.append(self.X[random_index])

  def _find_nearby_center(self, data_point):
    center_distances = []
    for center in self.k_centers:
      center_distance = eud(center, data_point)
      center_distances.append(center_distance)
    return np.argmin(center_distances)
  
  def _update_k_clusters(self):
    new_k_clusters = []
    for i in range(self.k):
      new_k_clusters.append(None)
    for index in range(len(self.X)):
      center_index = self._find_nearby_center(self.X[index])
      if(new_k_clusters[center_index] == None):
        new_k_clusters[center_index] = [index]
      else:
        new_k_clusters[center_index].append(index)
    self.k_clusters = new_k_clusters
  
  def _update_k_centers(self):
    new_k_centers = []
    for i in range(self.k):
      new_k_centers.append(None)
    for index in range(len(self.k_clusters)):
      current_cluster = []
      for data_index in self.k_clusters[index]:
        current_cluster.append(self.X[data_index])
      current_cluster = np.array(current_cluster)
      mean_of_cluster = np.mean(current_cluster, axis = 0)
      new_k_centers[index] = mean_of_cluster
    self.k_centers = new_k_centers

  def _get_predicted_labels(self):
    predicted_labels = []
    for i in range(self.n_rows):
      predicted_labels.append(None)
    for cluster_index in range(len(self.k_clusters)):
      for data_point_index in self.k_clusters[cluster_index]:
        predicted_labels[data_point_index] = int(cluster_index+1)
    return predicted_labels
  def plot(self):
    _, ax = plt.subplots()
    for cluster in self.k_clusters:
      cluster_t = self.X[cluster].T
      ax.scatter(*cluster_t)
    for center in self.k_centers_pp:
      ax.scatter(*center, marker = "+", linewidth = 10)
    plt.show()
  
  def run(self):
    self._init_k_random_centers()
    for _ in range(self.r):
      self._update_k_clusters()
      self._update_k_centers()
    predicted_labels = self._get_predicted_labels()
    return predicted_labels

if __name__ == "__main__":
  X = np.loadtxt(sys.argv[1], delimiter=',')
  k = int(sys.argv[2])
  r = int(sys.argv[3])
  output_file = sys.argv[4]
  iris_lloyd = IrisLloyd(X, k, r)
  y = iris_lloyd.run()
  np.savetxt(output_file, y, delimiter=',')
  print("Quantization error for Lloyd Clustering", qerror(k, X, y))
  iris_lloyd.plot()