# -*- coding: utf-8 -*-
"""KMeansPP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16o-ynqu35r1lCftjOa80itUFA4Yu5ImP
"""

import sys
import numpy as np
from numpy.random import seed
import math
import matplotlib.pyplot as plt
seed(12)

def eud(ss, dd):
  b = (ss-dd) * (ss - dd)
  su = 0
  for i in range(len(b)):
    su += b[i]
  return np.sqrt(su)

def qerror(k, X, y):
  res = 0
  for i in range(1, k+1):
    a = []
    for index in range(len(y)):
      if(y[index] == i):
        a.append(X[index])
    a_su = sum(a)
    a_mean = a_su/max(len(a), 1)
    dist = []
    for j in a:
      dist.append((j-a_mean)**2)
    for d in dist:
      res += sum(d)
  return res

class IrisKMeansPP:
  def __init__(self, X, k, r):
    self.X = X
    self.k = k
    self.r = r
    self.n_rows, self.n_cols = X.shape
    self.k_clusters = None
    self.k_centers_pp = None
  def _init_k_random_centers_pp(self):  
    self.k_centers_pp = []
    for i in range(k):
      if i == 0:
        first_random_index = np.random.choice(self.n_rows, 1, replace=False)
        for random_index in first_random_index:
          self.k_centers_pp.append(self.X[random_index])
      else:
        center_distances = []
        for index in range(self.n_rows):
          minimum_distance = math.inf
          for existing_center in range(len(self.k_centers_pp)):
            current_dist = eud(self.X[index], self.k_centers_pp[existing_center])
            if(minimum_distance > current_dist):
              minimum_distance = current_dist
          center_distances.append(minimum_distance)
        su = -1 * math.inf
        datapoint_index = None
        for cd in range(len(center_distances)):
          if(center_distances[cd] > su):
            su = center_distances[cd]
            datapoint_index = cd
        self.k_centers_pp.append(self.X[datapoint_index, :])

  def _find_nearby_center(self, data_point):
    center_distances = []
    for center in self.k_centers_pp:
      center_distance = eud(center, data_point)
      center_distances.append(center_distance)
    return np.argmin(center_distances)
  
  def _update_k_clusters(self):
    new_k_clusters = []
    for i in range(self.k):
      new_k_clusters.append(None)
    for index in range(len(self.X)):
      center_index = self._find_nearby_center(self.X[index])
      if(new_k_clusters[center_index] == None):
        new_k_clusters[center_index] = [index]
      else:
        new_k_clusters[center_index].append(index)
    self.k_clusters = new_k_clusters
  
  def _update_k_centers(self):
    new_k_centers = []
    for i in range(self.k):
      new_k_centers.append(None)
    for index in range(len(self.k_clusters)):
      current_cluster = []
      for data_index in self.k_clusters[index]:
        current_cluster.append(self.X[data_index])
      current_cluster = np.array(current_cluster)
      mean_of_cluster = np.mean(current_cluster, axis = 0)
      new_k_centers[index] = mean_of_cluster
    self.k_centers_pp = new_k_centers

  def _get_predicted_labels(self):
    predicted_labels = []
    for i in range(self.n_rows):
      predicted_labels.append(None)
    for cluster_index in range(len(self.k_clusters)):
      for data_point_index in self.k_clusters[cluster_index]:
        predicted_labels[data_point_index] = int(cluster_index+1)
    return predicted_labels
  
  def plot(self):
    _, ax = plt.subplots()
    for cluster in self.k_clusters:
      cluster_t = self.X[cluster].T
      ax.scatter(*cluster_t)
    for center in self.k_centers_pp:
      ax.scatter(*center, marker = "+", linewidth = 10)
    plt.show()
  
  def run(self):
    self._init_k_random_centers_pp()
    for _ in range(self.r):
      self._update_k_clusters()
      self._update_k_centers()
    predicted_labels = self._get_predicted_labels()
    return predicted_labels

if __name__ == "__main__":
  X = np.loadtxt(sys.argv[1], delimiter=',')
  k = int(sys.argv[2])
  r = int(sys.argv[3])
  output_file = sys.argv[4]
  iris_kmeans_pp = IrisKMeansPP(X, k, r)
  y = iris_kmeans_pp.run()
  np.savetxt(output_file, y, delimiter=',')
  print("Quantization error for KMeansPP Clustering", qerror(k, X, y))
  iris_kmeans_pp.plot()
